# -*- coding: utf-8 -*-
################################################################################
# Author:	Soeren Gebbert
#
# Copyright (C) 2009 Soeren Gebbert
#               mail to: soerengebbert <at> googlemail <dot> com
#
# License:
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

from optparse import OptionParser
import os
import os.path
import WPS_1_0_0.OGC_WPS_1_0_0 as wps

class GrassXMLtoDict():
    """ Convert a Grass WPS XML file into PyPWS process file"""
    def __init__(self):
        self._content = {}

    def setXMLFileName(self,  filename):
        self.__xmlFileName = filename
        if not os.path.isfile(self.__xmlFileName):
            raise IOError("Unable to open xml file")
            
    def setOutputFileName(self,  filename):
        self._outputFileName = filename
        self._output = open(self._outputFileName,  'w')
    
    def _closeOutput(self):
        self._output.close()
        
    def _parseXML(self):
        """Parse the XML file generated by PyXB and create the dictionary structure"""
        try:
            self.doc = wps.CreateFromDocument(file(self.__xmlFileName).read())
	    
            if len(self.doc.ProcessDescription) > 1:
                raise IOError("Only one Process is supported")
            
            for process in self.doc.ProcessDescription:
	        proc = {} 

	        proc['processVersion'] = str(process.processVersion)
	        proc['storeSupported'] = bool(process.storeSupported)
	        proc['statusSupported'] = bool(process.statusSupported)
		proc["Identifier"] = str(process.Identifier.value())

                if process.Metadata != None:
                    metaData = []
                    for meta in process.Metadata:
                        content = {}
                        if meta.title != None:
                            content["title"] = str(meta.title)
                        if meta.about != None:
                            content["about"] = str(meta.about)
                        if meta.arcrole != None:
                            content["arcrole"] = str(meta.arcrole)
                        if meta.actuate != None:
                            content["actuate"] = str(meta.actuate)
                        if meta.href != None:
                            content["href"] = str(meta.href)
                        if meta.role != None:
                            content["role"] = str(meta.role)
                        if meta.type != None:
                            content["type"] = str(meta.type)
                        if meta.show != None:
                            content["show"] = str(meta.show)
                        metaData.append(content)
                    proc["Metadata"] = metaData


	        ita = self._getTitleAbstract(process)
	        for key in ita.keys():
		    proc[key] = ita[key] 
	        proc["DataInputs"] = self._getDataInputs(process)
	        proc["ProcessOutputs"] = self._getProcessOutputs(process)
	        self._content["ProcessDescription"] = proc
        except:
            raise
            
    def convert(self):
        """This method must be override by subclasses, which implements the
        conversion from dict format into somethin else"""
        try:
            self._parseXML()
            self._output.write(str(self._content))
        except:
            raise
        finally:
            self._closeOutput()
            
    def _getTitleAbstract(self, element):
        """Create the title and abstract dict entries"""
        ita = {} 
        if element.Title.value() != None:
            ita["Title"] = str(element.Title.value()).replace('\'', '')
        if element.Abstract != None:
            ita["Abstract"] = str(element.Abstract.value()).replace('\'', '')
            
        return ita
        
    def _getDataInputs(self,  process):
        """Create data inputs  dict entries"""
        dataInputs = [] 
        for data in process.DataInputs.Input:
            input = {} 
            input["Identifier"] = str(data.Identifier.value())
            ita = self._getTitleAbstract(data)
            for key in ita.keys():
                input[key] = ita[key] 
                
            input["minOccurs"] = int(data.minOccurs)
            input["maxOccurs"] = int(data.maxOccurs)
            
            if data.ComplexData != None:
                input["ComplexData"] = self._getComplexData(data.ComplexData)
            if data.LiteralData != None:
                input["LiteralData"] = self._getLiteralData(data.LiteralData)
                
            dataInputs.append(input)
            
        return dataInputs
  
    def _getProcessOutputs(self,  process):
        """Create process outputs  dict entries"""
        processOutputs = [] 
        for data in process.ProcessOutputs.Output:
            output = {} 
            output["Identifier"] = str(data.Identifier.value())    
            ita = self._getTitleAbstract(data)
            for key in ita.keys():
                output[key] = ita[key] 
                
            if data.ComplexOutput != None:
                output["ComplexOutput"] = self._getComplexData(data.ComplexOutput)
            if data.LiteralOutput != None:
                output["LiteralOutput"] = self._getLiteralData(data.LiteralOutput)
                            
            processOutputs.append(output)
            
        return processOutputs

    def _getComplexData(self,  element):
        """Create complex data dict entries"""
        complexData = {}
        default = {}
        supported = []

        if element.Default.Format.MimeType != None:
            default["MimeType"] = str(element.Default.Format.MimeType)
        if element.Default.Format.Encoding != None:
            default["Encoding"] = str(element.Default.Format.Encoding)
        if element.Default.Format.Schema != None:
            default["Schema"] = str(element.Default.Format.Schema)
        complexData["Default"] = default

        for format in element.Supported.Format:
          supformat = {}
	  if format.MimeType != None:
	      supformat["MimeType"] = str(format.MimeType)
	  if element.Default.Format.Encoding != None:
	      supformat["Encoding"] = str(format.Encoding)
	  if element.Default.Format.Schema != None:
	      supformat["Schema"] = str(format.Schema)
	  if supformat:
	      supported.append(supformat)

        complexData["Supported"] = supported

        return complexData
        
    def _getLiteralData(self,  element):
        """Create literal data dict entries"""
        literalData = {}   
        allowedValues = [] 
        if element.DataType != None:
            literalData["DataType"] = str(element.DataType.value())
        if element.AllowedValues != None:
            for value in element.AllowedValues.Value:
                try:
                    if literalData["DataType"] == "boolean":
                        if str(value.value()) == "true":
                            allowedValues.append(True)
                        if str(value.value()) == "false":
                            allowedValues.append(False)
                    elif literalData["DataType"] == "integer":
                        allowedValues.append(int(value.value()))
                    elif literalData["DataType"] == "float":
                        allowedValues.append(float(value.value()))
                    else:
                        allowedValues.append(str(value.value()))
                except:
                    allowedValues.append(str(value.value()))
        if len(allowedValues) > 0:
            literalData["AllowedValues"] = allowedValues

        if element.DefaultValue != None:
            try:
                if literalData["DataType"] == "boolean":
                    if element.DefaultValue == "true":
                        literalData["DefaultValue"] = True
                    if element.DefaultValue == "false":
                        literalData["DefaultValue"] = False
                elif literalData["DataType"] == "integer":
                    literalData["DefaultValue"] = int(element.DefaultValue)
                elif literalData["DataType"] == "float":
                    literalData["DefaultValue"] = float(element.DefaultValue)
                else:
                    literalData["DefaultValue"] = str(element.DefaultValue)
            except:
                literalData["DefaultValue"] = str(element.DefaultValue)
        else:
            literalData["AnyValue"] = True

        if element.UOMs != None:
            UOMs = {}      
            supported = [] 
            if element.UOMs.Default != None:
                UOMs["Default"] = str(element.UOMs.Default.UOM.value())
            if element.UOMs.Supported != None:
                for i in element.UOMs.Supported.UOM:
                    supported.append(str(i.value()))
                UOMs["Supported"] = supported
                literalData["UOMs"] = UOMs
            
        return literalData
        # Literal output and BBox are not implemented yet

def main():
    """The main function which will be called if the script is executed directly"""

    usage = "usage: %prog [-help,--help] --xmlfile module.xml --pythonfile module.py]"
    description = "Use %prog to convert Grass 7.0 WPS XML process description files into a dictionary structure."
    parser = OptionParser(usage=usage, description=description)
    parser.add_option("-x", "--xmlfile", dest="xmlfile", help="The path to the grass WPS input xml file", metavar="FILE")
    parser.add_option("-p", "--pythonfile", dest="pythonfile", help="Path to the new created dict python file", metavar="FILE")

    (options, args) = parser.parse_args()

    if options.xmlfile == None or options.pythonfile == None:
        parser.print_help()
        parser.error("Booth file names must be provided")

    converter = GrassXMLtoDict()
    converter.setXMLFileName(options.xmlfile)
    converter.setOutputFileName(options.pythonfile)
    converter.convert()
    
    exit(0)

###############################################################################
if __name__ == "__main__":
    main()
